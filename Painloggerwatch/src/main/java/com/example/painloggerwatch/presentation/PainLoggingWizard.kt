package com.example.painloggerwatch.presentation // Make sure this is your correct package

import android.os.Bundle
import android.view.View // Needed for View.GONE and View.VISIBLE
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModelProvider
import androidx.viewpager2.widget.ViewPager2
import com.example.painlogger.databinding.ActivityWizardBinding // <-- Add this import for View Binding
import android.widget.Toast // For showing a message when finished
import androidx.lifecycle.lifecycleScope // Needed for lifecycleScope
import com.example.painlogger.fragments.BodyPartsFragment
import kotlinx.coroutines.launch // Needed for launch
import com.example.painlogger.fragments.GeneralFragment
import com.example.painlogger.fragments.TriggersFragment


// Activity to host the pain logging wizard (multi-step process)
class PainLoggingWizardActivity : AppCompatActivity() {
    private lateinit var binding: ActivityWizardBinding // Declare View Binding variable
    private lateinit var viewPager: ViewPager2
    private lateinit var viewModel: PainLoggingViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Inflate the layout using View Binding
        binding = ActivityWizardBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Get the ViewModel (shared across fragments)
        viewModel = ViewModelProvider(this)[PainLoggingViewModel::class.java]

        // Set up the ViewPager2
        viewPager = binding.viewPager // Access viewPager via binding
        viewPager.adapter = WizardAdapter(this) // Set the custom adapter
        viewPager.isUserInputEnabled = false // Disable swiping to force button navigation

        // Set up click listeners for the navigation buttons
        binding.btnBack.setOnClickListener { navigateBack() } // Access btnBack via binding
        binding.btnNext.setOnClickListener { navigateForward() } // Access btnNext via binding

        // Observe changes in the ViewPager to update button visibility (Back/Next/Finish)
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                updateButtonVisibility()
            }
        })

        // Initial button state setup
        updateButtonVisibility()
    }

    // Navigate to the previous fragment in the wizard
    internal fun navigateBack() {
        if (viewPager.currentItem > 0) {
            viewPager.currentItem -= 1 // Move to the previous page
        }
    }

    // Navigate to the next fragment or finish the wizard
    internal fun navigateForward() {
        // Save data from the current fragment before moving forward
        saveCurrentFragmentData()

        // Check if there are more pages in the wizard
        if (viewPager.currentItem < (viewPager.adapter?.itemCount ?: 0) - 1) {
            viewPager.currentItem += 1 // Move to the next page
        } else {
            // This is the last step, trigger the final data saving and finish the activity
            finishPainLogging()
        }
    }

    // Update the visibility and text of the navigation buttons based on the current page
    private fun updateButtonVisibility() {
        // Hide the Back button on the first page
        binding.btnBack.visibility = if (viewPager.currentItem == 0) View.GONE else View.VISIBLE // Access btnBack via binding
        // Change the Next button text to FINISH on the last page
        val lastPageIndex = (viewPager.adapter?.itemCount ?: 0) - 1
        binding.btnNext.text = if (viewPager.currentItem == lastPageIndex) "FINISH" else "NEXT" // Access btnNext via binding
    }

    // Save data from the currently visible fragment
    private fun saveCurrentFragmentData() {
        // Get the currently visible fragment using its tag (generated by ViewPager2)
        // The tag format is "f" + fragment_position (e.g., "f0", "f1", "f2")
        val currentFragment = supportFragmentManager.findFragmentByTag("f" + viewPager.currentItem)
        // Call the appropriate save method based on the fragment type
        when (currentFragment) {
            is GeneralFragment -> currentFragment.saveGeneralData()
            is TriggersFragment -> currentFragment.saveTriggersData()
            is BodyPartsFragment -> currentFragment.saveBodyPartsData()
        }
    }

    // Finalize the pain logging process (collect data from ViewModel and save)
    private fun finishPainLogging() {
        // Use a coroutine scope to collect data from StateFlows
        lifecycleScope.launch {
            // Get the collected data from the ViewModel
            val generalData = viewModel.generalData.value
            val triggers = viewModel.triggersData.value
            val detailedEntries = viewModel.detailedPainEntries.value

            // --- Implement your file saving logic here ---
            // This is where you would take the data (generalData, triggers, detailedEntries)
            // and write it to your CSV files, similar to the logic in your original MainActivity.java.
            // You might inject a file helper class here using Hilt to handle the file operations.

            // Example: Showing a Toast message with collected data (replace with actual saving)
            val message = """
                General Data: ${generalData?.painLevel}, ${generalData?.triggers}
                Triggers: ${triggers}
                Detailed Entries: ${detailedEntries?.size}
            """.trimIndent()
            Toast.makeText(this@PainLoggingWizardActivity, "Data collected: $message", Toast.LENGTH_LONG).show()
            // --- End of file saving logic placeholder ---

            // Finish the wizard activity
            finish()
        }
    }
}
